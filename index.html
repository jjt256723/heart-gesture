<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Give You My Heart</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
        }

        /* 隐藏视频元素，我们只需要它的数据 */
        #input-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* 镜像翻转 */
            opacity: 0; /* 隐藏视频，只看粒子 */
            z-index: 1;
            pointer-events: none;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
            color: white;
            pointer-events: none;
            transition: opacity 0.5s;
            text-shadow: 0 0 10px rgba(255, 105, 180, 0.8);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            z-index: 20;
            background: rgba(0,0,0,0.7);
            padding: 15px 30px;
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #love-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            color: #ff69b4;
            /* 修改字体大小单位为 vw，适配手机屏幕 */
            font-size: 12vw; 
            font-weight: bold;
            z-index: 5;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-shadow: 0 0 20px rgba(255, 105, 180, 0.5);
            white-space: nowrap;
        }

        #love-text.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .instruction {
            font-size: 1rem;
            opacity: 0.8;
            margin-top: 5px;
        }
    </style>
    <!-- 引入 MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <div style="font-size: 1.5rem; font-weight: bold;">✨ Magic Mirror ✨</div>
        <div class="instruction">请对着屏幕做出"比心"手势 (捏合拇指和食指)</div>
    </div>

    <div id="loading" class="loading">正在启动魔法引擎...<br><span style="font-size:0.8em; opacity:0.7">请允许使用摄像头</span></div>
    
    <div id="love-text">Love You 小蓉 ❤️</div>

    <div id="canvas-container">
        <video id="input-video" playsinline></video>
        <canvas id="output-canvas"></canvas>
    </div>

    <script>
        /**
         * 核心逻辑：
         * 1. 初始化摄像头和 MediaPipe Hands。
         * 2. 创建粒子系统。
         * 3. 在每一帧中：
         * - 检测手势。
         * - 如果检测到"捏合/比心"，将粒子目标设置为心形路径。
         * - 如果未检测到，将粒子目标设置为随机漂浮。
         * - 更新并绘制粒子。
         */

        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const loadingElement = document.getElementById('loading');
        const loveText = document.getElementById('love-text');

        let isHeartGesture = false;
        let particles = [];
        let width, height;
        
        // 粒子配置 (将在 resize 中动态设置)
        let PARTICLE_COUNT = 800; 
        let HEART_SCALE = 15;     
        
        // 初始化画布尺寸 & 响应式适配
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvasElement.width = width;
            canvasElement.height = height;

            // 手机端适配逻辑
            const isMobile = width < 768;
            
            // 手机端减少粒子数量以提升性能
            PARTICLE_COUNT = isMobile ? 500 : 800;
            
            // 动态计算爱心大小：保证爱心宽度约为屏幕较短边的 80%
            // 心形公式最大宽度大约是 16 * 2 = 32 个单位
            const minDim = Math.min(width, height);
            HEART_SCALE = minDim / 40; 

            createParticles();
        }
        window.addEventListener('resize', resize);

        // --- 粒子系统类 ---
        class Particle {
            constructor() {
                this.reset();
                this.x = Math.random() * width;
                this.y = Math.random() * height;
            }

            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.targetX = this.x;
                this.targetY = this.y;
                this.size = Math.random() * 2 + 1;
                // 默认颜色：浅粉色/白色
                const hue = Math.random() * 40 - 20; // -20 to 20 (Red/Pinkish)
                this.baseColor = `hsla(${340 + hue}, 100%, 70%,`;
                this.alpha = Math.random() * 0.5 + 0.3;
                this.friction = 0.94;
                this.ease = 0.08;
            }

            // 更新粒子位置
            update(isFormingHeart, heartIndex) {
                if (isFormingHeart) {
                    // 心形数学公式 (Parametric equation of a heart)
                    // t 范围 0 到 2*PI
                    const t = (heartIndex / PARTICLE_COUNT) * Math.PI * 2;
                    
                    // 16sin^3(t)
                    const hx = 16 * Math.pow(Math.sin(t), 3);
                    // 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                    const hy = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                    
                    // 缩放并居中
                    // 稍微增加一点随机扰动，让心形看起来是动态的能量体
                    const flutter = 2; 
                    this.targetX = (width / 2) + (hx * HEART_SCALE) + (Math.random() - 0.5) * flutter;
                    this.targetY = (height / 2) + (hy * HEART_SCALE) + (Math.random() - 0.5) * flutter;
                    
                    this.ease = 0.1; // 聚拢时速度稍快
                } else {
                    // 自由漂浮模式
                    this.targetX += this.vx * 2;
                    this.targetY += this.vy * 2;

                    // 边界反弹
                    if (this.targetX < 0 || this.targetX > width) this.vx *= -1;
                    if (this.targetY < 0 || this.targetY > height) this.vy *= -1;
                    
                    this.ease = 0.02; // 漂浮时惯性大
                }

                // 核心运动算法：向目标位置平滑插值 (Lerp)
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                
                this.x += dx * this.ease;
                this.y += dy * this.ease;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                // 聚拢时变红，散开时变白/粉
                ctx.fillStyle = this.baseColor + `${this.alpha})`;
                ctx.fill();
            }
        }

        function createParticles() {
            particles = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particles.push(new Particle());
            }
        }

        // --- MediaPipe Hands 配置 ---
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        // 手势检测逻辑
        hands.onResults((results) => {
            loadingElement.style.display = 'none';
            let detected = false;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                for (const landmarks of results.multiHandLandmarks) {
                    // 关键点索引：4 (拇指指尖), 8 (食指指尖)
                    const thumbTip = landmarks[4];
                    const indexTip = landmarks[8];

                    // 计算两点之间的欧几里得距离
                    // 注意：坐标是归一化的 (0.0 - 1.0)
                    const distance = Math.sqrt(
                        Math.pow(thumbTip.x - indexTip.x, 2) + 
                        Math.pow(thumbTip.y - indexTip.y, 2)
                    );

                    // 阈值判断：如果距离足够近，视为比心/捏合
                    // Z轴也用于深度判断，但简单的XY平面距离通常足够
                    if (distance < 0.08) { 
                        detected = true;
                        break; 
                    }
                }
            }
            
            isHeartGesture = detected;
        });

        // 启动摄像头
        // 注意：MediaPipe Camera Utils 默认会尝试选择合适的摄像头（通常是前置）
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });
        
        // 启动流程
        camera.start()
            .then(() => {
                console.log("Camera started");
            })
            .catch(err => {
                console.error(err);
                // 增加针对 HTTPS 的提示
                loadingElement.innerHTML = "无法访问摄像头<br>请确保使用 <b>HTTPS</b> 协议访问<br>或检查浏览器权限";
            });

        // --- 动画主循环 ---
        function animate() {
            // 1. 清空画布 (使用带透明度的黑色实现拖尾效果)
            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
            canvasCtx.fillRect(0, 0, width, height);

            // 2. 绘制粒子
            // 开启 lighter 混合模式让重叠粒子发光
            canvasCtx.globalCompositeOperation = 'lighter'; 

            particles.forEach((p, index) => {
                p.update(isHeartGesture, index);
                p.draw(canvasCtx);
            });

            canvasCtx.globalCompositeOperation = 'source-over';

            // 3. UI 状态更新
            if (isHeartGesture) {
                loveText.classList.add('show');
            } else {
                loveText.classList.remove('show');
            }

            requestAnimationFrame(animate);
        }

        // 初始化
        resize();
        animate();

    </script>
</body>
</html>